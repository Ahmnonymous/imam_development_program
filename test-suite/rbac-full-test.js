/**
 * Consolidated RBAC test runner for IDP.
 *
 * - Exercises backend RBAC via direct API calls against every module.
 * - Exercises frontend RBAC via Playwright-driven navigation and UI assertions.
 * - Produces a single JSON report and console summary.
 *
 * NOTE: Requires backend and frontend servers to be running locally (or via env overrides).
 */

const fs = require("fs");
const path = require("path");
const axios = require("axios");
const { chromium } = require("playwright");
const {
  MODULES,
  MODULE_ROUTE_MAP,
  ROLE_KEY_BY_ID,
  getAllowedMethods,
  isModuleAllowed,
  needsCenterRestriction,
} = require("../backend/src/constants/rbacMatrix");

const API_ROOT = (process.env.API_ROOT || process.env.API_BASE_URL || "http://localhost:5000").replace(/\/$/, "");
const FRONTEND_BASE_URL = (process.env.FRONTEND_BASE_URL || "http://localhost:5173").replace(/\/$/, "");
const REPORT_PATH = path.join(__dirname, "rbac-full-report.json");

const HTTP_METHODS = ["GET", "POST", "PUT", "PATCH", "DELETE"];

const SAMPLE_CREATE_BODY = {
  name: "RBAC Auto Test",
  description: "Automated RBAC verification payload",
  notes: "Generated by rbac-full-test.js",
};

const SAMPLE_UPDATE_BODY = {
  notes: "RBAC automated update attempt",
  status: "pending",
};

const NAV_ITEMS = [
  { key: "dashboard", label: "Dashboard", path: "/dashboard" },
  { key: "applicants", label: "Applicant Details", path: "/applicants" },
  { key: "centers", label: "Center Management", path: "/centers" },
  { key: "meetings", label: "Meetings Management", path: "/meetings" },
  { key: "suppliers", label: "Supplier Management", path: "/suppliers" },
  { key: "inventory", label: "Inventory Management", path: "/inventory" },
  { key: "reports", label: "Reports", path: "/reports/applicant-details" },
  { key: "lookups", label: "Lookup Setup", path: "/lookups" },
  { key: "policy", label: "Policy & Procedure", path: "/policy-library" },
  { key: "fileManager", label: "File Manager", path: "/FileManager" },
  { key: "chat", label: "Chat", path: "/chat" },
];

const POLICY_MANAGE_PATH = "/lookups/policy-and-procedure";

axios.defaults.timeout = 10_000;

const ROLE_DIRECTORY = [
  {
    key: "AppAdmin",
    roleId: ROLE_KEY_BY_ID ? Object.entries(ROLE_KEY_BY_ID).find(([, k]) => k === "AppAdmin")?.[0] : 1,
    username: "admin",
    password: "12345",
    centerId: null,
    navExpectation: {
      dashboard: true,
      applicants: true,
      centers: true,
      meetings: true,
      suppliers: true,
      inventory: true,
      reports: true,
      lookups: true,
      policy: true,
      fileManager: true,
      chat: true,
    },
    uiExpectations: {
      canCreateApplicants: true,
      canAddPolicy: true,
    },
  },
  {
    key: "HQ",
    roleId: 2,
    username: "hquser",
    password: "12345",
    centerId: 1,
    navExpectation: {
      dashboard: true,
      applicants: true,
      centers: true,
      meetings: true,
      suppliers: false,
      inventory: false,
      reports: true,
      lookups: true,
      policy: true,
      fileManager: true,
      chat: true,
    },
    uiExpectations: {
      canCreateApplicants: true,
      canAddPolicy: true,
    },
  },
  {
    key: "OrgAdmin",
    roleId: 3,
    username: "orgadmin",
    password: "12345",
    centerId: 1,
    navExpectation: {
      dashboard: true,
      applicants: true,
      centers: false,
      meetings: true,
      suppliers: false,
      inventory: false,
      reports: true,
      lookups: true,
      policy: true,
      fileManager: true,
      chat: true,
    },
    uiExpectations: {
      canCreateApplicants: true,
      canAddPolicy: false,
    },
  },
  {
    key: "OrgExecutive",
    roleId: 4,
    username: "orgexeuser",
    password: "12345",
    centerId: 1,
    navExpectation: {
      dashboard: true,
      applicants: true,
      centers: false,
      meetings: false,
      suppliers: false,
      inventory: false,
      reports: true,
      lookups: false,
      policy: true,
      fileManager: false,
      chat: false,
    },
    uiExpectations: {
      canCreateApplicants: false,
      canAddPolicy: false,
    },
  },
  {
    key: "OrgCaseworker",
    roleId: 5,
    username: "orgcaseuser",
    password: "12345",
    centerId: 1,
    navExpectation: {
      dashboard: true,
      applicants: true,
      centers: false,
      meetings: false,
      suppliers: false,
      inventory: false,
      reports: true,
      lookups: false,
      policy: true,
      fileManager: true,
      chat: true,
    },
    uiExpectations: {
      canCreateApplicants: true,
      canAddPolicy: false,
    },
  },
];

const MODULE_SETTINGS = (() => {
  const map = {};
  MODULE_ROUTE_MAP.forEach(({ module, prefixes }) => {
    if (!map[module]) {
      map[module] = {
        base: prefixes[0],
      };
    }
  });

  map[MODULES.LOOKUP] = {
    base: "/api/lookup/Race",
    write: "/api/lookup/TestTable",
  };
  map[MODULES.REPORTS] = {
    base: "/api/reports/applicant-details",
  };
  map[MODULES.CENTERS] = {
    base: "/api/centerdetail",
  };
  map[MODULES.MEETINGS] = {
    base: "/api/hseqToolboxMeeting",
  };
  map[MODULES.SUPPLIER] = {
    base: "/api/supplierprofile",
  };
  map[MODULES.INVENTORY] = {
    base: "/api/inventoryitems",
  };
  map[MODULES.TASKS] = {
    base: "/api/tasks?file_id=1",
  };
  map[MODULES.COMMENTS] = {
    base: "/api/comments?file_id=1",
  };
  map[MODULES.RELATIONSHIPS] = {
    base: "/api/relationships?file_id=1",
  };
  map[MODULES.HOME_VISITS] = {
    base: "/api/homevisit?file_id=1",
  };
  map[MODULES.FINANCIAL_ASSISTANCE] = {
    base: "/api/financialassistance",
  };
  map[MODULES.FOOD_ASSISTANCE] = {
    base: "/api/foodassistance",
  };
  map[MODULES.ATTACHMENTS] = {
    base: "/api/attachments",
  };
  map[MODULES.PROGRAMS] = {
    base: "/api/programs",
  };
  map[MODULES.FINANCIAL_ASSESSMENT] = {
    base: "/api/financialassessment",
  };
  map[MODULES.APPLICANT_INCOME] = {
    base: "/api/applicantincome",
  };
  map[MODULES.APPLICANT_EXPENSE] = {
    base: "/api/applicantexpense",
  };
  map[MODULES.EMPLOYEE] = {
    base: "/api/employee",
  };
  map[MODULES.TRAINING] = {
    base: "/api/traininginstitutions",
  };
  map[MODULES.POLICY] = {
    base: "/api/policyandprocedure",
  };
  map[MODULES.LOOKUP] = {
    base: "/api/lookup/Race",
    write: "/api/lookup/TestScope",
  };
  map[MODULES.FILE_MANAGER] = {
    base: "/api/folders",
  };
  map[MODULES.PERSONAL_FILES] = {
    base: "/api/personalfiles",
  };
  map[MODULES.CHAT] = {
    base: "/api/conversations",
    write: "/api/messages",
  };
  map[MODULES.AUTH] = {
    base: "/api/auth/login",
  };
  map[MODULES.DASHBOARD] = {
    base: "/api/dashboard/applicant-statistics",
  };

  return map;
})();

const results = [];

const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

const joinUrl = (base, routePath) => {
  if (routePath.startsWith("http://") || routePath.startsWith("https://")) {
    return routePath;
  }
  return `${base}${routePath.startsWith("/") ? routePath : `/${routePath}`}`;
};

const recordResult = (entry) => {
  results.push({
    timestamp: new Date().toISOString(),
    ...entry,
  });
};

const determineModuleOperations = (moduleKey, role) => {
  if (moduleKey === MODULES.AUTH) {
    return [
      {
        method: "POST",
        url: "/api/auth/login",
        description: "POST /api/auth/login with valid credentials",
        body: {
          username: role.username,
          password: role.password,
        },
      },
    ];
  }

  const settings = MODULE_SETTINGS[moduleKey] || {};
  const basePath = settings.base || "/api";
  const writePath = settings.write || basePath;
  const idPath =
    settings.id ||
    `${writePath}${writePath.includes("?") ? "&" : "/"}999999`;

  const operations = [
    {
      method: "GET",
      url: basePath,
      description: `GET ${basePath}`,
    },
    {
      method: "POST",
      url: writePath,
      description: `POST ${writePath}`,
      body: SAMPLE_CREATE_BODY,
    },
    {
      method: "PUT",
      url: idPath,
      description: `PUT ${idPath}`,
      body: SAMPLE_UPDATE_BODY,
    },
    {
      method: "DELETE",
      url: idPath,
      description: `DELETE ${idPath}`,
    },
  ];

  // Ensure at least two operations even for read-only modules by trimming extras if needed.
  return operations;
};

const loginAsRole = async (role) => {
  const loginUrl = joinUrl(API_ROOT, "/api/auth/login");
  // eslint-disable-next-line no-console
  console.log(`[RBAC] [${role.key}] Starting backend login @ ${loginUrl}`);
  try {
    const response = await axios.post(
      loginUrl,
      {
        username: role.username,
        password: role.password,
      },
      {
        validateStatus: () => true,
      },
    );

    if (!response.data || !response.data.token) {
      // eslint-disable-next-line no-console
      console.error(
        `[RBAC] [${role.key}] Login failed - status ${response.status}, body ${JSON.stringify(response.data)}`,
      );
      throw new Error(`Login failed for ${role.key}: ${response.status} ${JSON.stringify(response.data)}`);
    }

    // eslint-disable-next-line no-console
    console.log(`[RBAC] [${role.key}] Login success`);
    return {
      token: response.data.token,
      payload: response.data.user,
      userInfo: response.data.userInfo,
    };
  } catch (error) {
    // eslint-disable-next-line no-console
    console.error(`[RBAC] [${role.key}] Login threw error:`, error.message);
    throw error;
  }
};

const performBackendChecks = async (role, token) => {
  // eslint-disable-next-line no-console
  console.log(`[RBAC] [${role.key}] Initialising backend checks`);
  const client = axios.create({
    baseURL: API_ROOT,
    headers: {
      Authorization: `Bearer ${token}`,
    },
    validateStatus: () => true,
  });

  const uniqueModules = new Set(Object.values(MODULES));

  // eslint-disable-next-line no-console
  console.log(`[RBAC] [${role.key}] Backend module loop starting (${uniqueModules.size} modules)`);
  for (const moduleKey of uniqueModules) {
    if (!MODULE_SETTINGS[moduleKey]) {
      continue;
    }

    const operations = determineModuleOperations(moduleKey, role);
    const moduleAllowed = isModuleAllowed(role.key, moduleKey);
    const allowedMethods = getAllowedMethods(role.key, moduleKey);
    const requiresTenantScope = needsCenterRestriction(role.key);

    // eslint-disable-next-line no-console
    console.log(
      `[RBAC] [${role.key}] Backend module ${moduleKey} (${operations.length} operations) - allowed:${moduleAllowed} methods:${allowedMethods.join(",")}`,
    );
    for (const operation of operations) {
      const expectedAllowed =
        moduleAllowed && allowedMethods.includes(operation.method);

      // eslint-disable-next-line no-console
      console.log(
        `[RBAC] [${role.key}]  -> Backend ${operation.method} ${operation.url} (expect ${expectedAllowed ? "ALLOW" : "DENY"})`,
      );

      let response;
      try {
        response = await client.request({
          url: operation.url,
          method: operation.method,
          data: operation.body,
          headers:
            operation.method === "POST" || operation.method === "PUT" || operation.method === "PATCH"
              ? { "Content-Type": "application/json" }
              : undefined,
        });
      } catch (error) {
        // eslint-disable-next-line no-console
        console.error(
          `[RBAC] [${role.key}]  !! Backend ${operation.method} ${operation.url} threw error: ${error.message}`,
        );
        recordResult({
          role: role.key,
          module: moduleKey,
          type: "backend",
          action: `${operation.method} ${operation.url}`,
          expected: expectedAllowed ? "allow" : "deny",
          actualStatus: error.code || "axios-error",
          pass: false,
          tenantScope: "error",
          navigationVisible: "n/a",
          details: error.stack,
        });
        continue;
      }

      const status = response.status;
      const isAuthError = status === 401 || status === 403;
      const passed = expectedAllowed ? !isAuthError : isAuthError;

      let tenantScopePass = "n/a";
      if (
        passed &&
        expectedAllowed &&
        operation.method === "GET" &&
        requiresTenantScope &&
        Array.isArray(response.data) &&
        response.data.length > 0 &&
        role.centerId !== null &&
        role.centerId !== undefined
      ) {
        const itemsWithCenter = response.data.filter(
          (item) => item && Object.prototype.hasOwnProperty.call(item, "center_id"),
        );
        if (itemsWithCenter.length > 0) {
          tenantScopePass = itemsWithCenter.every(
            (item) => String(item.center_id) === String(role.centerId),
          );
        } else {
          tenantScopePass = "no-center-field";
        }
      }

      recordResult({
        role: role.key,
        module: moduleKey,
        type: "backend",
        action: `${operation.method} ${operation.url}`,
        expected: expectedAllowed ? "allow" : "deny",
        actualStatus: status,
        pass: Boolean(passed),
        tenantScope: tenantScopePass,
        navigationVisible: "n/a",
        details: response.data && typeof response.data === "object" ? JSON.stringify(response.data).slice(0, 200) : null,
      });
    }
  }
  // eslint-disable-next-line no-console
  console.log(`[RBAC] [${role.key}] Completed backend checks`);
};

const ensureLoggedInUI = async (page, role) => {
  // eslint-disable-next-line no-console
  console.log(`[RBAC] [${role.key}] Navigating to login UI`);
  await page.goto(`${FRONTEND_BASE_URL}/login`, { waitUntil: "domcontentloaded" });
  // eslint-disable-next-line no-console
  console.log(`[RBAC] [${role.key}] Filling login form`);
  await page.fill('input[name="username"]', role.username);
  await page.fill('input[name="password"]', role.password);
  await Promise.all([
    page.waitForURL(/dashboard/i, { timeout: 25000 }),
    page.click('button:has-text("Log In")'),
  ]);
  await page.waitForSelector("#side-menu", { timeout: 20000 });
  // eslint-disable-next-line no-console
  console.log(`[RBAC] [${role.key}] UI login successful`);
};

const performFrontendChecks = async (role) => {
  // eslint-disable-next-line no-console
  console.log(`[RBAC] [${role.key}] Launching Playwright browser`);
  let browser;
  try {
    browser = await chromium.launch({ headless: true });
  } catch (error) {
    // eslint-disable-next-line no-console
    console.error(`[RBAC] [${role.key}] Browser launch failed:`, error.message);
    recordResult({
      role: role.key,
      module: "frontend",
      type: "frontend",
      action: "browser-launch",
      expected: "launch",
      actualStatus: error.message,
      pass: false,
      tenantScope: "n/a",
      navigationVisible: null,
      details: error.stack,
    });
    return;
  }

  const context = await browser.newContext();
  const page = await context.newPage();

  try {
    await ensureLoggedInUI(page, role);

    // Navigation visibility checks
    for (const item of NAV_ITEMS) {
      // eslint-disable-next-line no-console
      console.log(`[RBAC] [${role.key}] Checking navigation visibility: ${item.label}`);
      const locator = page.locator(`#side-menu a:has-text("${item.label}")`);
      const count = await locator.count();
      const visible = count > 0;
      const expectedVisible = Boolean(role.navExpectation[item.key]);
      const pass = visible === expectedVisible;

      recordResult({
        role: role.key,
        module: item.key,
        type: "frontend",
        action: `navigation:${item.label}`,
        expected: expectedVisible ? "visible" : "hidden",
        actualStatus: visible ? "visible" : "hidden",
        pass,
        tenantScope: "n/a",
        navigationVisible: visible,
        details: null,
      });
    }

    // Route access checks
    for (const item of NAV_ITEMS) {
      const expectedVisible = Boolean(role.navExpectation[item.key]);
      const expectedRouteAccess =
        item.key === "lookups"
          ? expectedVisible && role.key !== "OrgCaseworker" && role.key !== "OrgExecutive"
          : expectedVisible;

      // eslint-disable-next-line no-console
      console.log(`[RBAC] [${role.key}] Navigating to route ${item.path} (expect ${expectedRouteAccess ? "ALLOW" : "DENY"})`);
      await page.goto(`${FRONTEND_BASE_URL}/dashboard`, { waitUntil: "domcontentloaded" });
      await wait(500);
      await page.goto(`${FRONTEND_BASE_URL}${item.path}`, {
        waitUntil: "domcontentloaded",
      });
      await wait(500);
      const currentURL = page.url();
      const unauthorized =
        currentURL.includes("/unauthorized") || currentURL.includes("/login");
      const pass = expectedRouteAccess ? !unauthorized : unauthorized;

      recordResult({
        role: role.key,
        module: `${item.key}-route`,
        type: "frontend",
        action: `route:${item.path}`,
        expected: expectedRouteAccess ? "allow" : "deny",
        actualStatus: unauthorized ? "redirected" : "allowed",
        pass,
        tenantScope: "n/a",
        navigationVisible: expectedVisible,
        details: unauthorized ? currentURL : null,
      });
    }

    // Applicant create button check
    // eslint-disable-next-line no-console
    console.log(`[RBAC] [${role.key}] Checking applicant create button`);
    await page.goto(`${FRONTEND_BASE_URL}/applicants`, {
      waitUntil: "domcontentloaded",
    });
    await wait(1000);
    const applicantButtonCount = await page
      .locator('button[title="Create New Applicant"]')
      .count();
    const applicantButtonVisible = applicantButtonCount > 0;
    const expectedApplicantButton = Boolean(role.uiExpectations.canCreateApplicants);
    recordResult({
      role: role.key,
      module: "applicants-create",
      type: "frontend",
      action: "ui:create-applicant-button",
      expected: expectedApplicantButton ? "visible" : "hidden",
      actualStatus: applicantButtonVisible ? "visible" : "hidden",
      pass: applicantButtonVisible === expectedApplicantButton,
      tenantScope: "n/a",
      navigationVisible: role.navExpectation.applicants,
      details: null,
    });

    // Policy add button check
    // eslint-disable-next-line no-console
    console.log(`[RBAC] [${role.key}] Checking policy add button`);
    await page.goto(`${FRONTEND_BASE_URL}${POLICY_MANAGE_PATH}`, {
      waitUntil: "domcontentloaded",
    });
    await wait(1000);
    const policyButtonCount = await page
      .locator('button:has-text("Add New")')
      .count();
    const policyButtonVisible = policyButtonCount > 0;
    const expectedPolicyButton = Boolean(role.uiExpectations.canAddPolicy);
    recordResult({
      role: role.key,
      module: "policy-add",
      type: "frontend",
      action: "ui:policy-add-button",
      expected: expectedPolicyButton ? "visible" : "hidden",
      actualStatus: policyButtonVisible ? "visible" : "hidden",
      pass: policyButtonVisible === expectedPolicyButton,
      tenantScope: "n/a",
      navigationVisible: role.navExpectation.policy,
      details: null,
    });
  } catch (error) {
    recordResult({
      role: role.key,
      module: "frontend",
      type: "frontend",
      action: "ui-error",
      expected: "no-error",
      actualStatus: error.message,
      pass: false,
      tenantScope: "n/a",
      navigationVisible: null,
      details: error.stack,
    });
  } finally {
    await context.close();
    await browser.close();
  }
};

const run = async () => {
  for (const role of ROLE_DIRECTORY) {
    // eslint-disable-next-line no-console
    console.log(`\n[RBAC] ==== Starting role ${role.key} ====`);
    try {
      const login = await loginAsRole(role);
      try {
        await performBackendChecks(role, login.token);
      } catch (error) {
        // eslint-disable-next-line no-console
        console.error(`[RBAC] [${role.key}] Backend checks error:`, error.message);
      }
      try {
        await performFrontendChecks(role);
      } catch (error) {
        // eslint-disable-next-line no-console
        console.error(`[RBAC] [${role.key}] Frontend checks error:`, error.message);
      }
    } catch (error) {
      recordResult({
        role: role.key,
        module: "login",
        type: "backend",
        action: "auth/login",
        expected: "allow",
        actualStatus: error.message,
        pass: false,
        tenantScope: "n/a",
        navigationVisible: null,
        details: error.stack,
      });
    }
    // eslint-disable-next-line no-console
    console.log(`[RBAC] ==== Finished role ${role.key} ====`);
  }

  const summaryMap = new Map();
  results.forEach((entry) => {
    const key = `${entry.role}|${entry.module}`;
    if (!summaryMap.has(key)) {
      summaryMap.set(key, {
        role: entry.role,
        module: entry.module,
        total: 0,
        passes: 0,
        fails: 0,
      });
    }
    const summary = summaryMap.get(key);
    summary.total += 1;
    if (entry.pass) {
      summary.passes += 1;
    } else {
      summary.fails += 1;
    }
  });

  const summary = Array.from(summaryMap.values()).sort((a, b) => {
    if (a.role === b.role) {
      return a.module.localeCompare(b.module);
    }
    return a.role.localeCompare(b.role);
  });

  const reportPayload = {
    generatedAt: new Date().toISOString(),
    apiRoot: API_ROOT,
    frontendBaseUrl: FRONTEND_BASE_URL,
    results,
    summary,
  };

  fs.writeFileSync(REPORT_PATH, JSON.stringify(reportPayload, null, 2), "utf-8");

  // eslint-disable-next-line no-console
  console.log("\nRBAC Consolidated Summary");
  // eslint-disable-next-line no-console
  console.table(
    summary.map(({ role, module, total, passes, fails }) => ({
      role,
      module,
      total,
      passes,
      fails,
    })),
  );

  const totalFailures = summary.reduce((acc, item) => acc + item.fails, 0);
  if (totalFailures > 0) {
    process.exitCode = 1;
  }
};

run().catch((error) => {
  // eslint-disable-next-line no-console
  console.error("RBAC consolidated test failure:", error);
  process.exitCode = 1;
});


